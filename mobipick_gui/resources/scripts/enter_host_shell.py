#!/usr/bin/env python3
"""Drop privileges inside the mobipick_cmd container to match the host user."""
from __future__ import annotations

import grp
import os
import pwd
import re
import shlex
import stat
import sys
from pathlib import Path


def _parse_int(value: str | None, default: int) -> int:
    if not value:
        return default
    try:
        return int(value)
    except ValueError:
        return default


def _sanitize_name(raw: str | None, *, prefix: str, fallback_id: int) -> str:
    if raw:
        candidate = re.sub(r"[^A-Za-z0-9_.-]", "-", raw.strip())
    else:
        candidate = ""
    if not candidate:
        candidate = f"{prefix}{fallback_id}"
    if candidate.lower() == "root":
        candidate = f"{prefix}{fallback_id}"
    if candidate[0].isdigit():
        candidate = f"{prefix}-{candidate}"
    return candidate[:32]


def _ensure_group(gid: int, name: str) -> str:
    try:
        group = grp.getgrgid(gid)
    except KeyError:
        pass
    else:
        return group.gr_name

    entry = f"{name}:x:{gid}:\n"
    with open("/etc/group", "a", encoding="utf-8") as handle:
        handle.write(entry)
    return name


def _ensure_user(uid: int, gid: int, name: str, home: Path) -> str:
    try:
        user = pwd.getpwuid(uid)
    except KeyError:
        user = None
    if user:
        return user.pw_name

    home.mkdir(parents=True, exist_ok=True)
    entry = f"{name}:x:{uid}:{gid}::{home}:{os.environ.get('SHELL', '/bin/bash')}\n"
    with open("/etc/passwd", "a", encoding="utf-8") as handle:
        handle.write(entry)
    return name


def _relax_permissions(path: Path) -> None:
    """Ensure the host user can traverse ``path`` if it lives under /root."""

    try:
        stats = path.stat()
    except FileNotFoundError:
        return

    if not str(path).startswith("/root"):
        return

    # If the directory already grants group/other read & execute, leave it alone.
    mode = stat.S_IMODE(stats.st_mode)
    required_bits = stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH
    if mode & required_bits == required_bits:
        return

    new_mode = (stats.st_mode & ~0o777) | (mode | required_bits)
    os.chmod(path, new_mode)


def _select_home(home_hint: str | None) -> tuple[Path, Path | None]:
    """Return the home directory and optional RC source for the dropped user."""

    default_home = Path("/root")
    default_rc = default_home / ".bashrc"

    if not home_hint:
        return default_home, None

    candidate = Path(home_hint).expanduser()

    if candidate == default_home:
        return candidate, None

    try:
        candidate_exists = candidate.exists()
    except OSError:
        candidate_exists = False

    # If the hinted directory cannot be inspected we still attempt to use it â€“
    # ``_ensure_user`` will create it if necessary. Only fall back to ``/root``
    # when the caller did not request a specific location.
    if not candidate_exists and not candidate.is_absolute():
        return default_home, None

    candidate_rc = candidate / ".bashrc"

    if candidate_rc.exists() or not default_rc.exists():
        return candidate, None

    return candidate, default_rc


def _ensure_home_ownership(home: Path, uid: int, gid: int) -> None:
    """Make sure the host user owns their home directory when possible."""

    if home == Path("/root"):
        return

    try:
        home.mkdir(parents=True, exist_ok=True)
    except OSError:
        return

    try:
        os.chown(home, uid, gid)
    except PermissionError:
        return


def _ensure_rc_stub(home: Path, rc_source: Path | None, uid: int, gid: int) -> None:
    """Create a ~/.bashrc that sources ``rc_source`` if required."""

    if not rc_source:
        return

    target = home / ".bashrc"

    if target.exists():
        return

    try:
        target.parent.mkdir(parents=True, exist_ok=True)
        rc_quoted = shlex.quote(str(rc_source))
        target.write_text(
            "# Generated by mobipick enter_host_shell helper\n"
            f"if [ -f {rc_quoted} ]; then\n"
            f"    . {rc_quoted}\n"
            "fi\n",
            encoding="utf-8",
        )
        os.chmod(target, 0o644)
        os.chown(target, uid, gid)
    except OSError:
        return


def main(argv: list[str]) -> "None":
    uid = _parse_int(os.environ.get("MOBIPICK_UID"), 0)
    gid = _parse_int(os.environ.get("MOBIPICK_GID"), uid)

    command = argv[1:] or ["bash"]

    if uid == 0:
        os.execvp(command[0], command)
        raise RuntimeError("execvp returned")

    requested_user = _sanitize_name(os.environ.get("MOBIPICK_HOST_USER"), prefix="host", fallback_id=uid)
    requested_group = _sanitize_name(os.environ.get("MOBIPICK_HOST_GROUP"), prefix="hostgrp", fallback_id=gid)
    home_path, rc_source = _select_home(os.environ.get("MOBIPICK_HOST_HOME"))

    _ensure_group(gid, requested_group)
    user_name = _ensure_user(uid, gid, requested_user, home_path)
    _ensure_home_ownership(home_path, uid, gid)
    _ensure_rc_stub(home_path, rc_source, uid, gid)

    cwd = Path.cwd().resolve()
    for candidate in (cwd, *cwd.parents):
        _relax_permissions(candidate)
        if candidate == Path("/"):
            break

    script_dir = Path(__file__).resolve().parent
    for candidate in (script_dir, *script_dir.parents):
        _relax_permissions(candidate)
        if candidate == Path("/"):
            break

    os.setgroups([gid])
    os.setgid(gid)
    os.setuid(uid)

    os.environ["HOME"] = str(home_path)
    os.environ["USER"] = user_name
    os.environ.setdefault("LOGNAME", user_name)

    os.execvp(command[0], command)
    raise RuntimeError("execvp returned")


if __name__ == "__main__":
    main(sys.argv)
